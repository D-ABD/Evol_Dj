from ..utils.levels import get_user_level, LEVEL_THRESHOLDS, get_user_progress

from datetime import timedelta
from collections import defaultdict

from django.db import models
from django.utils.timezone import now
from django.core.validators import MinValueValidator, MaxValueValidator
from django.core.exceptions import ValidationError
from django.utils.functional import cached_property
from django.db.models import Avg, Count

from django.conf import settings
User = settings.AUTH_USER_MODEL



# üèÖ Badge obtenu
class Badge(models.Model):
    """
    Mod√®le repr√©sentant un badge obtenu par un utilisateur.
    Les badges sont des r√©compenses pour des accomplissements sp√©cifiques.
    
    API Endpoints sugg√©r√©s:
    - GET /api/badges/ - Liste des badges de l'utilisateur courant
    - GET /api/users/{id}/badges/ - Liste des badges d'un utilisateur sp√©cifique
    - GET /api/badges/recent/ - Badges r√©cemment obtenus
    
    Exemple de s√©rialisation JSON:
    {
        "id": 1,
        "name": "Niveau 3",
        "description": "Tu as atteint le niveau 3 üí™",
        "icon": "ü•à",
        "date_obtenue": "2025-04-20",
        "level": 3
    }
    """
    name = models.CharField(max_length=100)  # Nom du badge
    description = models.TextField()         # Description du badge
    icon = models.CharField(max_length=100)  # Ic√¥ne (chemin ou identifiant)
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="badges")
    date_obtenue = models.DateField(auto_now_add=True)  # Date d'obtention
    level = models.PositiveIntegerField(null=True, blank=True)  # Niveau du badge (optionnel)

    class Meta:
        verbose_name = "Badge"
        verbose_name_plural = "Badges"
        ordering = ['-date_obtenue']
        unique_together = ('name', 'user')  # Un utilisateur ne peut avoir qu'un badge avec le m√™me nom
        
        """
        Filtres API recommand√©s:
        - name (exact, contains)
        - date_obtenue (range, gte, lte)
        - level (exact, gte, lte)
        """

    def __str__(self):
        """Repr√©sentation en cha√Æne de caract√®res du badge"""
        return f"{self.name} ({self.user.username})"

    def was_earned_today(self, reference_date=None):
        """
        V√©rifie si le badge a √©t√© obtenu aujourd'hui.

        Args:
            reference_date (date, optional): Date de r√©f√©rence (aujourd'hui par d√©faut)

        Returns:
            bool: True si le badge a √©t√© obtenu aujourd'hui, False sinon
            
        Utilisation dans l'API:
            Ce champ peut √™tre expos√© comme bool√©en calcul√© 'is_new' dans la s√©rialisation
            pour permettre √† l'interface d'afficher un indicateur visuel pour les nouveaux badges.
        """
        if reference_date is None:
            reference_date = now().date()
        return self.date_obtenue == reference_date

    def save(self, *args, **kwargs):
        """
        Surcharge de la m√©thode save pour cr√©er automatiquement 
        une notification lorsqu'un badge est attribu√©.
        
        Note pour l'API:
        Lors de la cr√©ation d'un badge via l'API, une notification sera √©galement g√©n√©r√©e.
        Il n'est pas n√©cessaire de cr√©er explicitement une notification dans la vue API.
        """
        is_new = self.pk is None
        super().save(*args, **kwargs)

        if is_new:
            # ‚è± Import local pour √©viter les imports circulaires
            from .notification_model import Notification
            from .event_log_model import EventLog

            # Cr√©e une notification pour informer l'utilisateur
            Notification.objects.create(
                user=self.user,
                message=f"üèÖ Nouveau badge d√©bloqu√© : {self.name}",
                notif_type="badge"
            )

            # Enregistre l'√©v√©nement dans les logs du syst√®me
            EventLog.objects.create(
                user=self.user,
                action="attribution_badge",
                description=f"Badge '{self.name}' attribu√© √† {self.user.username}"
            )


# üß© BadgeTemplate : tous les badges d√©finissables
class BadgeTemplate(models.Model):
    """
        Mod√®le d√©finissant les diff√©rents badges disponibles dans l'application.
        Contient les crit√®res d'attribution des badges aux utilisateurs.
        
        Chaque template d√©finit un type de badge qui peut √™tre d√©bloqu√© selon des conditions
        sp√©cifiques (nombre d'entr√©es, r√©gularit√©, humeur, etc.). Le mod√®le inclut 
        √©galement des √©l√©ments visuels pour enrichir l'exp√©rience utilisateur.
        
        API Endpoints sugg√©r√©s:
        - GET /api/badges/templates/ - Liste tous les templates de badges
        - GET /api/badges/templates/{id}/ - D√©tails d'un template sp√©cifique
        - GET /api/badges/templates/categories/ - Templates group√©s par cat√©gorie
        - GET /api/badges/templates/{id}/progress/ - Progression de l'utilisateur vers ce badge
        
        Exemple de s√©rialisation JSON:
        {
            "id": 3,
            "name": "R√©gulier",
            "description": "Tu as √©crit chaque jour pendant 5 jours ‚úçÔ∏è",
            "icon": "üìÖ",
            "condition": "5 jours cons√©cutifs avec entr√©es",
            "level": 1,
            "color_theme": "#4CAF50",
            "animation_url": "https://cdn.myevol.app/animations/regular.json",
            "progress": {
                "percent": 80,
                "current": 4,
                "target": 5,
                "unlocked": false
            }
        }
    
    """

    name = models.CharField(max_length=100, unique=True)  # Nom unique du badge
    description = models.TextField()                      # Description du badge
    icon = models.CharField(max_length=100)               # Ic√¥ne (chemin ou identifiant)
    condition = models.CharField(max_length=255)          # Description de la condition d'obtention
    level = models.PositiveIntegerField(null=True, blank=True)  # Niveau du badge (optionnel)


    animation_url = models.URLField(
        blank=True,
        null=True,
        help_text="Lien vers une animation Lottie ou GIF pour enrichir l'affichage du badge"
    )
    color_theme = models.CharField(default="#FFD700", max_length=20)  # couleur du badge
    class Meta:
        verbose_name = "Mod√®le de badge"
        verbose_name_plural = "Mod√®les de badges"
        
        """
        Filtres API recommand√©s:
        - name (exact, contains)
        - condition (contains)
        - level (exact, gte, lte)
        """

    def __str__(self):
        """Repr√©sentation en cha√Æne de caract√®res du template de badge"""
        return self.name

    def check_unlock(self, user):
        """
        V√©rifie si un utilisateur remplit les conditions pour d√©bloquer ce badge.

        Cette m√©thode contient la logique d√©taill√©e pour chaque type de badge.

        Args:
            user (User): L'utilisateur √† v√©rifier

        Returns:
            bool: True si l'utilisateur remplit les conditions, False sinon
            
        Utilisation dans l'API:
            Cette m√©thode est id√©ale pour le calcul de la progression vers les badges:
            
            1. Pour les endpoints /api/badges/progress/ qui montrent tous les badges
               et la progression de l'utilisateur vers leur obtention
            
            2. Pour calculer le pourcentage de progression pour des badges complexes,
               comme les badges de s√©quence (jours cons√©cutifs)
               
        Exemples d'utilisation:
            # V√©rifier si l'utilisateur peut d√©bloquer ce badge
            can_unlock = badge_template.check_unlock(request.user)
            
            # Dans un s√©rialiseur avec un champ calcul√©
            @property
            def is_unlocked(self):
                return self.instance.check_unlock(self.context['request'].user)
        """
        total = user.total_entries()
        mood_avg = user.mood_average(7)

        # Dictionnaire des conditions
        conditions = {
            "Premi√®re entr√©e": total >= 1,
            "R√©gulier": user.has_entries_every_day(5),
            "Discipline": user.has_entries_every_day(10),
            "R√©silience": user.has_entries_every_day(15),
            "L√©gende du Journal": user.has_entries_every_day(30),
            "Ambassadeur d'humeur": mood_avg is not None and mood_avg >= 9,
            "Productivit√©": user.entries_today() >= 3,
            "Objectif rempli !": user.all_objectives_achieved(),
            "Pers√©v√©rance": total >= 100,
        }

        # Condition personnalis√©e
        if self.name in conditions:
            return conditions[self.name]

        # Cas sp√©cial pour les badges de niveau (ex: "Niveau 3")
        if self.name.startswith("Niveau"):
            try:
                level_number = int(self.name.split(" ")[1])
                return get_user_level(total) >= level_number
            except (ValueError, IndexError):
                return False

        return False  # Par d√©faut, on ne d√©bloque pas
    
    def get_progress(self, user):
        """
        Calcule la progression d'un utilisateur vers l'obtention de ce badge.

        Args:
            user (User): L'utilisateur concern√©

        Returns:
            dict: Contient les informations de progression vers le badge :
                {
                    'percent': Pourcentage de progression (int),
                    'current': Valeur actuelle (ex. nombre d'entr√©es),
                    'target': Seuil √† atteindre pour d√©bloquer le badge,
                    'unlocked': Bool√©en indiquant si le badge est d√©j√† d√©bloqu√©
                }

        Utilis√© dans l'API pour visualiser les barres de progression.
        """
        total = user.total_entries()  # Entr√©es du journal

        # ‚úÖ Cas 1 : Badge d√©j√† d√©bloqu√© ‚Üí progression compl√®te, mais on garde target coh√©rent
        if user.badges.filter(name=self.name).exists():
            try:
                if self.name.startswith("Niveau"):
                    level_number = int(self.name.split(" ")[1])
                    progress_data = get_user_progress(total)
                    return {
                        'percent': 100,
                        'unlocked': True,
                        'current': total,
                        'target': progress_data["next_threshold"]
                    }
            except Exception:
                pass  # Si probl√®me dans la logique, on retombe sur le fallback plus bas

            return {
                'percent': 100,
                'unlocked': True,
                'current': total,
                'target': total
            }

        # ‚úÖ Cas 2 : Badge "Premi√®re entr√©e"
        if self.name == "Premi√®re entr√©e":
            return {
                'percent': 100 if total >= 1 else 0,
                'current': min(total, 1),
                'target': 1,
                'unlocked': total >= 1
            }

        # ‚úÖ Cas 3 : Badge de type "Niveau X"
        elif self.name.startswith("Niveau"):
            try:
                level_number = int(self.name.split(" ")[1])
                progress_data = get_user_progress(total)
                return {
                    'percent': 100 if progress_data["level"] >= level_number else progress_data["progress"],
                    'current': total,
                    'target': progress_data["next_threshold"],
                    'unlocked': progress_data["level"] >= level_number
                }
            except (ValueError, IndexError, KeyError):
                return {
                    'percent': 0,
                    'unlocked': False,
                    'current': total,
                    'target': 0
                }

        # ‚úÖ Cas 4 : Tous les autres badges personnalis√©s
        return {
            'percent': 100 if self.check_unlock(user) else 0,
            'unlocked': self.check_unlock(user),
            'current': total,
            'target': 1
        }
